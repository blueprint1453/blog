<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>react组件的生命周期 | blueprint的博客</title>
    <meta name="generator" content="VuePress 1.7.1">
    <script src="https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone/babel.min.js"></script>
    <meta name="description" content="专注于前端技术栈">
    
    <link rel="preload" href="/blog/assets/css/0.styles.a903d165.css" as="style"><link rel="preload" href="/blog/assets/js/app.08582795.js" as="script"><link rel="preload" href="/blog/assets/js/2.bea9b8b0.js" as="script"><link rel="preload" href="/blog/assets/js/41.45453a21.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.f094a42f.js"><link rel="prefetch" href="/blog/assets/js/11.df13f6a2.js"><link rel="prefetch" href="/blog/assets/js/12.946ac660.js"><link rel="prefetch" href="/blog/assets/js/13.2c46ed50.js"><link rel="prefetch" href="/blog/assets/js/14.b105fa13.js"><link rel="prefetch" href="/blog/assets/js/15.708a71e6.js"><link rel="prefetch" href="/blog/assets/js/16.b3b0d831.js"><link rel="prefetch" href="/blog/assets/js/17.e1b75c8c.js"><link rel="prefetch" href="/blog/assets/js/18.fe00f300.js"><link rel="prefetch" href="/blog/assets/js/19.d55e64bc.js"><link rel="prefetch" href="/blog/assets/js/20.21139e64.js"><link rel="prefetch" href="/blog/assets/js/21.8d581f0b.js"><link rel="prefetch" href="/blog/assets/js/22.c23fb302.js"><link rel="prefetch" href="/blog/assets/js/23.08ef3395.js"><link rel="prefetch" href="/blog/assets/js/24.6893fb74.js"><link rel="prefetch" href="/blog/assets/js/25.553e86dd.js"><link rel="prefetch" href="/blog/assets/js/26.3525d7a5.js"><link rel="prefetch" href="/blog/assets/js/27.d0600e38.js"><link rel="prefetch" href="/blog/assets/js/28.cbaf1559.js"><link rel="prefetch" href="/blog/assets/js/29.3d9743ec.js"><link rel="prefetch" href="/blog/assets/js/3.691d9991.js"><link rel="prefetch" href="/blog/assets/js/30.875260e3.js"><link rel="prefetch" href="/blog/assets/js/31.171e3383.js"><link rel="prefetch" href="/blog/assets/js/32.5b4b522b.js"><link rel="prefetch" href="/blog/assets/js/33.f9c2ba74.js"><link rel="prefetch" href="/blog/assets/js/34.15cf2b1d.js"><link rel="prefetch" href="/blog/assets/js/35.007e117d.js"><link rel="prefetch" href="/blog/assets/js/36.45d89f26.js"><link rel="prefetch" href="/blog/assets/js/37.e84af326.js"><link rel="prefetch" href="/blog/assets/js/38.13771274.js"><link rel="prefetch" href="/blog/assets/js/39.a412b670.js"><link rel="prefetch" href="/blog/assets/js/4.0515568e.js"><link rel="prefetch" href="/blog/assets/js/40.05a0b8cb.js"><link rel="prefetch" href="/blog/assets/js/42.4980fb2e.js"><link rel="prefetch" href="/blog/assets/js/43.aed0c501.js"><link rel="prefetch" href="/blog/assets/js/44.02ad5c3b.js"><link rel="prefetch" href="/blog/assets/js/45.e6d5c7f6.js"><link rel="prefetch" href="/blog/assets/js/46.fad203fa.js"><link rel="prefetch" href="/blog/assets/js/47.fb08130a.js"><link rel="prefetch" href="/blog/assets/js/48.b9c8cd5d.js"><link rel="prefetch" href="/blog/assets/js/49.6fb00b14.js"><link rel="prefetch" href="/blog/assets/js/5.616f4b04.js"><link rel="prefetch" href="/blog/assets/js/50.efe4c65c.js"><link rel="prefetch" href="/blog/assets/js/51.0c5513ee.js"><link rel="prefetch" href="/blog/assets/js/52.bbf39996.js"><link rel="prefetch" href="/blog/assets/js/53.4bbd31b3.js"><link rel="prefetch" href="/blog/assets/js/54.4ccd4e5e.js"><link rel="prefetch" href="/blog/assets/js/55.6ace7e4a.js"><link rel="prefetch" href="/blog/assets/js/56.2d1f4735.js"><link rel="prefetch" href="/blog/assets/js/57.112701ba.js"><link rel="prefetch" href="/blog/assets/js/58.f15129ca.js"><link rel="prefetch" href="/blog/assets/js/6.8c37003d.js"><link rel="prefetch" href="/blog/assets/js/7.9d3fea96.js"><link rel="prefetch" href="/blog/assets/js/8.665069b1.js"><link rel="prefetch" href="/blog/assets/js/9.63c32f9c.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.a903d165.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">blueprint的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><span class="title">前端</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端" class="mobile-dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/javascript/" class="nav-link">
  js笔记
</a></li><li class="dropdown-item"><!----> <a href="/blog/html/" class="nav-link">
  html和浏览器
</a></li><li class="dropdown-item"><!----> <a href="/blog/css/" class="nav-link">
  css笔记
</a></li><li class="dropdown-item"><!----> <a href="/blog/regexp/" class="nav-link">
  正则
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="js框架和库" class="dropdown-title"><span class="title">js框架和库</span> <span class="arrow down"></span></button> <button type="button" aria-label="js框架和库" class="mobile-dropdown-title"><span class="title">js框架和库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/vue/" class="nav-link">
  vue专题
</a></li><li class="dropdown-item"><!----> <a href="/blog/react/" class="nav-link">
  react专题
</a></li><li class="dropdown-item"><!----> <a href="/blog/redux/" class="nav-link">
  redux
</a></li><li class="dropdown-item"><!----> <a href="/blog/axios/" class="nav-link">
  axios
</a></li></ul></div></div><div class="nav-item"><a href="/blog/algorithm/" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="/blog/interview/" class="nav-link">
  面试题
</a></div> <a href="https://github.com/blueprint1453/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><span class="title">前端</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端" class="mobile-dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/javascript/" class="nav-link">
  js笔记
</a></li><li class="dropdown-item"><!----> <a href="/blog/html/" class="nav-link">
  html和浏览器
</a></li><li class="dropdown-item"><!----> <a href="/blog/css/" class="nav-link">
  css笔记
</a></li><li class="dropdown-item"><!----> <a href="/blog/regexp/" class="nav-link">
  正则
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="js框架和库" class="dropdown-title"><span class="title">js框架和库</span> <span class="arrow down"></span></button> <button type="button" aria-label="js框架和库" class="mobile-dropdown-title"><span class="title">js框架和库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/vue/" class="nav-link">
  vue专题
</a></li><li class="dropdown-item"><!----> <a href="/blog/react/" class="nav-link">
  react专题
</a></li><li class="dropdown-item"><!----> <a href="/blog/redux/" class="nav-link">
  redux
</a></li><li class="dropdown-item"><!----> <a href="/blog/axios/" class="nav-link">
  axios
</a></li></ul></div></div><div class="nav-item"><a href="/blog/algorithm/" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="/blog/interview/" class="nav-link">
  面试题
</a></div> <a href="https://github.com/blueprint1453/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="react组件的生命周期"><a href="#react组件的生命周期" class="header-anchor">#</a> react组件的生命周期</h2> <p>react组件的生命周期分为初始化渲染、更新、卸载三个大阶段，具体的执行过程如下</p> <ol><li><p>调用构造函数，初始化state</p></li> <li><p>调用componentWillMount, 准备进入渲染阶段</p></li> <li><p>执行render方法，将jsx转化为虚拟DOM</p></li> <li><p>将虚拟DOM映射生成真实DOM，并触发componentDidMount方法</p></li> <li><p>某一时刻，调用setState方法，进入更新渲染流程阶段</p></li> <li><p>调用shouldComponentUpdate，可以在这里指示组件要不要进行更新渲染的操作</p></li> <li><p>调用componentWillUpdate方法</p></li> <li><p>执行render方法，生成新的虚拟DOM</p></li> <li><p>新旧虚拟DOM比对，更新变化的节点 触发componentDidupdate方法</p></li></ol> <p>注意5-6讲的是state变化的更新，如果是props变化导致的更新，那么会增加componentWillRecieveProps这个个生命周期方法</p> <ol start="9"><li>组件卸载,触发componentWillUnmount方法</li></ol> <h2 id="react-16-之后生命周期的变化"><a href="#react-16-之后生命周期的变化" class="header-anchor">#</a> react 16 之后生命周期的变化</h2> <ul><li>挂载阶段</li></ul> <ol><li>constructor</li> <li>static getDerivedStateFromProps (UNSAFE_componentWillMount 不推荐使用)</li> <li>render</li> <li>componentDidMount</li></ol> <ul><li>更新阶段</li></ul> <ol><li>static getDrivedStateFromProps (UNSAFE_componentWillReceiveProps不推荐使用)</li> <li>shouldComponentUpdate</li> <li>render</li> <li>getSnapshotBeforeUpdate  (UNSAFE_componentWillUpdate不推荐使用)</li> <li>componentDidUpdate</li></ol> <ul><li><p>卸载
componentWillUnmount</p></li> <li><p>补充 错误处理</p></li></ul> <ol><li>static getDrivedStateFromError</li> <li>componentDidCatch</li></ol> <h2 id=""><a href="#" class="header-anchor">#</a> -----------------------------------------------------------------------</h2> <h2 id="setstate方法"><a href="#setstate方法" class="header-anchor">#</a> setState方法</h2> <ul><li><p>setState并不能保证会立即更新，通常情况下会延迟调用。setState会将更新缓冲到一个队列中，将当前的react事件处理程序结束后批量进行更新渲染。</p></li> <li><p>之所以要延迟更新，是因为当前的执行环境可能会同时有多次的setState的调用，如果调用setState后立即更新，连续的多次的更新会影响性能。</p></li> <li><p>什么情况下同步，什么情况延迟更新呢？
当setState在react的事件处理程序中被调用时，如dom合成事件，生命周期方法中，setState的更新时延迟的
当setState在定时器，网络请求，或promise回调中，setState的更新时同步的，可以立即获取新的state</p></li> <li><p>setState延迟更新的原理
在setState的内部实现中，会根据一个叫做isBatchingUpdates标识判断是将更新放入队列中还是直接更新，默认情况下isBatchingUpdate是false，但是有一个batchedUpdates方法，他会将isBatchingUpdate设置为true，而react的事件处理程序每次被调用时，都会调用batchedUpdates方法</p></li></ul> <h2 id="调用-setstate-之后发生了什么"><a href="#调用-setstate-之后发生了什么" class="header-anchor">#</a> 调用 setState 之后发生了什么？</h2> <p><a href="https://zhuanlan.zhihu.com/p/43522965" target="_blank" rel="noopener noreferrer">揭密React setState<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="-2"><a href="#-2" class="header-anchor">#</a> -----------------------------------------------------------------------</h2> <h2 id="react的diff算法原理"><a href="#react的diff算法原理" class="header-anchor">#</a> react的diff算法原理</h2> <ul><li><p>参考文章 <a href="https://www.cnblogs.com/forcheng/p/13246874.html" target="_blank" rel="noopener noreferrer">深入理解React：diff 算法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p>react diff策略一 Web UI中DOM节点跨层级的移动操作特别少，可以忽略不计，所以react只对虚拟dom树的同一层级进行比对。如果是跨层级的话，只有创建节点和删除节点的操作。</p></li> <li><p>相同类型的组件具有类似的dom结构 对于不同类型的组件，默认不需要进行比较操作，直接重新创建。
对于同类型组件， 通过让开发人员自定义shouldComponentUpdate()方法来进行比较优化，减少组件不必要的比较</p></li> <li><p>对于同一层级的一组子节点，通过唯一id区分
当节点处于同一层级时，diff提供三种节点操作：删除、插入、移动。</p></li></ul> <ol><li>新的虚拟DOM出现新的节点时，执行插入操作</li> <li>新的虚拟dom中，某个节点已经改变，执行删除操作</li> <li>新的dom中，兄弟节点本身没有发生变化，只是兄弟间顺序发生变化，执行移动操作</li></ol> <h2 id="-3"><a href="#-3" class="header-anchor">#</a> -----------------------------------------------------------------------</h2> <h2 id="高阶组件"><a href="#高阶组件" class="header-anchor">#</a> 高阶组件</h2> <p><a href="https://zhuanlan.zhihu.com/p/61711492?utm_source=wechat_session" target="_blank" rel="noopener noreferrer">React 中的高阶组件及其应用场景<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>
定义 接受组件作为参数，返回新的组件的函数</p> <ul><li>高阶组件是一个纯函数，不应该对输入组件做更改</li> <li>高阶组件应该避免在render方法中使用，因为这样做会导致每次render都重新执行一遍组件的创建操作</li> <li>不能在函数式（无状态）组件上使用 ref 属性，因为它没有实例</li></ul> <p>##高级组件主要有两种形式，属性代理和反向继承##</p> <ol><li>属性代理 返回一个继承了react，Component的新组件的高阶组件</li></ol> <ul><li>操作 props 比如新增props</li> <li>抽离state 将子件共同的状态的方法抽取到state，然后在高阶组件中合并到props中</li> <li>通过 ref 访问到组件实例</li> <li>用其他元素包裹传入的组件 WrappedComponent</li></ul> <ol start="2"><li>反向继承 返回了一个继承了传入的组件的新组建</li></ol> <ul><li>操作 state 可以操作传入组件的state，一般不建议做</li> <li>渲染劫持 对传入组件的渲染进行改写</li></ul> <p>##高阶组件的问题##</p> <ol><li>静态方法丢失</li> <li>ref属性无法透传</li> <li></li></ol> <h2 id="-4"><a href="#-4" class="header-anchor">#</a> -----------------------------------------------------------------------</h2> <h2 id="合成事件"><a href="#合成事件" class="header-anchor">#</a> 合成事件</h2> <ul><li><p>react的事件处理采用合成事件，合成事件是对浏览器原生事件的跨浏览器封装，拥有和浏览器原生事件相同的接口。</p></li> <li><p>react合成事件采用对象池进行管理，事件处理程序在调用结束后会被回收，其属性会被重置为null，所以异步访问的合成事件某个属性的话会出现无效的情况</p></li> <li><p>解决合成事件属性异步访问无效的情况？</p> <ol><li>可以使用变量保存方式</li> <li>调用e.pesist(),该方法会将合成事件从对象池移除，就不会被回收重置了。但是react 17已经废除了该方法</li></ol></li></ul> <h2 id="react-hooks"><a href="#react-hooks" class="header-anchor">#</a> react hooks</h2> <p>为复用react组件代码提供的一种方案，在之前主要通过高阶组件和render props来实现,hooks让函数式组建拥有了自己的状态</p> <ul><li><p>react内置了useState,useEffect,useContext等hooks</p></li> <li><p>useState接受一个初始值，返回一个state和更新state的函数</p></li> <li><p>useEffect接受一个函数作为参数，会在每次组件渲染后触发</p> <ol><li>useEffect会在每次渲染前把之前订阅清理掉</li> <li>useEffect在渲染后延迟更新，不会阻塞ui</li> <li>useEffect每次渲染都会触发，为了避免每次触发，可以在第二个参数数组中放入其依赖的变量</li></ol></li> <li><p>useContext接受一个react context对象并返回context的当前值，其值是有上层组件中距离当前组件最近的context的Provider决定</p></li> <li><p>useReducer useState 的替代方案。它接收一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法</p></li> <li><p>hooks使用规则</p></li></ul> <ol><li>只在react函数的顶层使用hooks，不要在循环中、条件语句中和内部函数中使用hooks</li> <li>只在react函数中调用hooks，不要在普通js函数中使用他们</li> <li></li></ol> <h2 id="分割线"><a href="#分割线" class="header-anchor">#</a> -----------------------------分割线------------------------------------------</h2> <h2 id="react的性能优化"><a href="#react的性能优化" class="header-anchor">#</a> react的性能优化</h2> <p><a href="https://zhuanlan.zhihu.com/p/74229420?utm_source=wechat_session" target="_blank" rel="noopener noreferrer">浅谈React性能优化的方向<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="分割线-2"><a href="#分割线-2" class="header-anchor">#</a> -----------------------------分割线------------------------------------------</h2> <h2 id="说说对redux"><a href="#说说对redux" class="header-anchor">#</a> 说说对redux</h2> <h2 id="分割线-3"><a href="#分割线-3" class="header-anchor">#</a> -----------------------------分割线------------------------------------------</h2> <h2 id="说说对react-redux、connect的实现原理"><a href="#说说对react-redux、connect的实现原理" class="header-anchor">#</a> 说说对react-redux、connect的实现原理</h2> <ul><li><p>react-redux将组件分为容器组件和ui组件
ui组件就是只显示视图的组件，不会涉及到redux api的操作
容器组件就是包含状态逻辑的组件，会使用redux的api</p></li> <li><p>react-redux提供了一个Provider组件，其内部通过react context将store往组件树中向下传递</p></li> <li><p>react-redux 提供了一个connect函数，这是一个高阶函数，其返回值是一个高阶组件，connect</p></li> <li><p>可以接受两个参数，分别负责被包裹组件的组件的输入和输出</p></li></ul> <ol><li>mapStateToProps 第一个参数是一个函数，返回了一个对象，将state映射成props</li> <li>mapDispatchToProps 第二个参数是一个函数，返回一个对象，将用户的输入映射成redux的action</li> <li>connect函数返回的高阶组件内部代码中，订阅了redux store的变化，并且在变化后刷新组件，在render函数返回的组件中注入了mapStateToProp和mapDispatchToProps，这样组件就可以通过props使用他们了</li></ol> <h2 id="分割线-4"><a href="#分割线-4" class="header-anchor">#</a> -----------------------------分割线------------------------------------------</h2> <h2 id="react-context"><a href="#react-context" class="header-anchor">#</a> react context</h2> <ul><li><p>context有关的文章
<a href="https://zhuanlan.zhihu.com/p/50336226" target="_blank" rel="noopener noreferrer">避免React Context导致的重复渲染<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <a href="https://zhuanlan.zhihu.com/p/74229420?utm_source=wechat_session" target="_blank" rel="noopener noreferrer">浅谈React性能优化的方向<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p>context api
context api 为react应用提供了不需要层层传递props就能在组件数传递数据的方案</p></li> <li><p>合理使用context api
context可以穿透React.memo和shouldupdate的比对，一旦context的值发生，会引起context包裹的所有的子组件的重新渲染。所以context api的使用需要遵循一些原则</p></li></ul> <ol><li>context中只放置必要的、关键的、被大多数组件共享的数据，比如鉴权组价</li> <li>粗粒度的订阅context，在父组件订阅context，通过props传递给子组件</li> <li>将context的provider组件封装成独立的组件在使用可以避免不必要的渲染。</li></ol> <h2 id="分割线-5"><a href="#分割线-5" class="header-anchor">#</a> -----------------------------分割线------------------------------------------</h2> <h2 id="react-中的元素和组件有什么不同"><a href="#react-中的元素和组件有什么不同" class="header-anchor">#</a> React 中的元素和组件有什么不同</h2> <ul><li>元素是不可变的普通对象，用来描述你想要渲染的组件或 DOM 节点。  元素一旦被创建，你就无法更改它的子元素或者属性。一个元素就像电影的单帧：它代表了某个特定时刻的 UI。</li> <li>组件可以是类或者函数，他将 props 作为输入然后返回一个元素的树形结构作为输出。</li></ul></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/blueprint1453/blog/edit/master/docs/plan/react.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----></footer> <!----> </main></div><div class="global-ui"><!----></div></div>
    <script src="/blog/assets/js/app.08582795.js" defer></script><script src="/blog/assets/js/2.bea9b8b0.js" defer></script><script src="/blog/assets/js/41.45453a21.js" defer></script>
  </body>
</html>
