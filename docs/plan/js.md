## js的数据类型

1. 数据类型的分类

- 从大的分类来说，js的数据类型分为基本类型和对象类型

- js的基本数据类型有number,string,boolean,null,undifined,symbol

- 对象类型，也叫复杂类型或引用类型，又可分为普通对象，函数，数组等子类型

2. 基本的数据类型和复杂类型的区别

 - 基本类型变量保存的是值本身，复杂类型保存的内存的一个地址，这个地址指向复杂类型数据在内存的位置

 - 基本类型的变量在赋值给另外一个拷贝的是值本身，对新的变量的修改操作不会再影响到原先的变量。而复杂类型的变量的赋值拷贝的是地址，对新变量的操作本质上还是对同一份内存数据的操作

- 基本类型的变量存储在栈中，位数固定，按顺序访问；复杂类型的数据存储在堆内存中，堆内存可以动态为复杂类型的数据分配内存。



-----------------------------------分割线--------------------------------------------

## 原型和原型链
- 在js中构造函数被声明后，js引擎会为它自动分配一个叫prototype的属性，这个对象被称为这个构造函数的实例的原型对象，所有实例都能共享该原型对象的实例和方法
- 如果要访问一个对象中不存在的属性，那么就会去它的原型对象查找，如果原型对象也不存在，那么会继续去原型对象的原型中查找，知道原型链的顶端为止。

- 原型对象的问题
原型中属性和方法被所有实例共享，如果属性是函数外的引用对象，那么任何一个实例对其的修改会同步到所有的实例的访问中去

- 判断属性是否存在-hasOwnProperty
只有对象本身的属性才会返回true

## 判断属性是否存在-in操作符
对象和对象的原型的属性都会返回true



-----------------------------------分割线--------------------------------------------

## js的继承

### 构造继承
- 子类通过调用父类的构造函数继承父类的属性和方法
- 缺点 
1. 每个子类的实例都要执行一遍父类的构造函数执行
2. 构造函数中我们一般只会初始化属性，即使我们在构造器中定义一些父类的实例的方法，那子类中继承的这些方法是各自生成的，不能共享

### 原型继承
原型继承的方式实现有多中
- 通过new 关键字实现
```js
function Parent(){}

function Child(){}

Child.prototype = new Parent()
Child.prototype.constructor = Child

var child = new Child()

```
- 通过Object.create方法实现
- 通过Object.setPrototypeOf实现

- 缺点
1. 子类实例的方法和属性（这里指的是从原型继承的属性和方法）的定义必须放在原型赋值之后，否则会被覆盖
2. 将父类实例的直接赋值给子类的原型 简单粗暴不优雅

### 组合继承

构造继承和原型继承结合的方式

### es6的继承

- ES5继承和ES6继承的区别
1. es5的继承是先创建了实例对象，并将this指向这个实例对象，然后是将父类的属性和方法添加到this中
2. es6的继承是先将父类的属性和方法添加到了this上面，然后是调用子类的构造器改变了this的指向

### es5模拟es6的继承
1. 将子类的__proto__指向父类的构造函数，实现静态属性的继承
2. 将子类的prototype.__proto__指向父类的prototype，实现原型属性和方法的继承
3. 子类调用父类的构造函数实现构造函数中属性的继承

### minx模式的实现
- 实现多个类的接口

```js
function mix(...mixins) {
  class Mix {
    constructor() {
      for (let mixin of mixins) {
        copyProperties(this, new mixin()); // 拷贝实例属性
      }
    }
  }

  for (let mixin of mixins) {
    copyProperties(Mix, mixin); // 拷贝静态属性
    copyProperties(Mix.prototype, mixin.prototype); // 拷贝原型属性
  }

  return Mix;
}

function copyProperties(target, source) {
  for (let key of Reflect.ownKeys(source)) {
    if ( key !== 'constructor'
      && key !== 'prototype'
      && key !== 'name'
    ) {
      let desc = Object.getOwnPropertyDescriptor(source, key);
      Object.defineProperty(target, key, desc);
    }
  }
}

class DistributedEdit extends mix(Loggable, Serializable) {
  // ...
}

```



-----------------------------------分割线--------------------------------------------

## 闭包的概念

- 函数会持有它定义时所在的词法环境的引用，即使函数在它声明的此法作用域之外执行。但是当一个函数内部返回一个函数的时候，这个内部函数就持有了外部函数的词法环境，外部函数执行完毕后，内部函数如果继续在其他地方引用的话，外部函数的词法环境会继续被那个内部函数持有，被引用的变量会继续存在于内存中，不会被垃圾回收器回收掉。

- 优点
1. 避免变量的命名冲突
2. 实现私有变量和模块化



-----------------------------------分割线--------------------------------------------

## 内存泄漏

- 遗忘的的定时器，dom事件侦听器
当离开当前页面或组件被销毁时，定时器和dom事件侦听器如果不进行取消的，这些定时器和事件侦听器还会继续工作。

- 意外的全局变量
全局变量存在于整个应用或者页面的生命周期中，如果某局部变量被意外注册到全局的话，就会造成内存泄漏

- 网络请求的回调
当组件或页面被销毁时，网络请求的回调使用到了页面的某些内容，这些内容不会被垃圾回收

- 闭包使用不当

- 遗忘的dom元素
当一个dom元素被某个js变量引用时，即使dom元素被移除后，因为在其他地方引用，依然不会被垃圾回收



-----------------------------------分割线--------------------------------------------

## js的事件循环
- [JavaScript 运行机制详解：再谈Event Loop](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)
- [详解JavaScript中的Event Loop（事件循环）机制](https://blog.csdn.net/qq_33572444/article/details/79106935)

- js引擎是单线程的，一个任务在开始之前必须等待上一个任务执行结束。
- 浏览器的是多线程的，除了js引擎，还有网络请求线程、定时器线程、dom事件触发线程等
  ajax请求、定时器、dom事件都是交由浏览器的这些线程去处理后再将回调任务交给js引擎执行
- 因为浏览器的线程的任务往往是异步的，当然es6也新增了异步的api js引擎需要一定时间才能拿到结果，所以js中的任务就有了同步和异步的概念，所以为了协调这些任务的进行，有了事件循环的概念。

1. js在执行过程中，先执行当前的同步任务，遇到上述的异步任务，交给专门的浏览器线程处理，继续往前执行当前执行其他任务
2. 浏览器线程执行的任务会在完成后将注册的回调任务推入一个事件队列中
3. 浏览器执行完了当前所有的同步任务，开始从事件队列中取出任务一个个执行
4. 当任务队列清空完成后，js继续下一个事件循环
5. 异步任务又分为宏任务和微任务，相应的事件回调会推到相应上午任务队列中，当前执行栈中同步任务结束后，会先取出微任务队列中的任务先执行完毕，然后在执行宏任务队列中的任务




-----------------------------------分割线--------------------------------------------
## commonjs和es6 module模块化的区别
[ES6-模块与-CommonJS-模块的差异](https://es6.ruanyifeng.com/#docs/module-loader#ES6-%E6%A8%A1%E5%9D%97%E4%B8%8E-CommonJS-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B7%AE%E5%BC%82)

- commonjs模块输出的是一个值得拷贝，es6 module输出的是值的引用
  1. 由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。
- commonjs模块在运行时加载，es6 module在编译阶段输出接口
- commonjs模块是同步加载，并且只在第一次加载时运行，后面都是从缓存中获取，es6 module是异步加载，有一个独立的模块依赖的解析阶段，不会被缓存
- commonjs模块是单个值导出，es6可以导出多个值


-----------------------------------分割线--------------------------------------------
## 垃圾回收算法
1. 在V8中,主要将内存分为新生代和老生代两代。新生代中的对象为存活时间较短的对象, 老生代中的对象为存活时间较长或常驻内存的对象。
2. 新生代中的内存一分为二，将内存分为使用空间和闲置空间。分配对象时先分配到使用空间，当开始进行垃圾回收后，将存活的对象复制到闲置空间，非存活对象占用空间被释放，然后两个空间角色互相。
3. 上述通过牺牲空间换时间的算法非常适合生命周期短的新生代，但是，当一个对象经过多次复制，生命周期较长的时候或则To空间不足的时候，对象会被分配到进入到老生代中，需要采用新的算法进行垃圾回收。
4. 老生代中内存开始进行垃圾回收时，遍历堆对象，标记存活对象，然后清除没有被标记的对象
5. 为了降低全堆垃圾回收带来的停顿时间,V8先从标记阶段入手,将原本要一口气停顿完成的动作改为增量标记(incremental marking),也就是拆分为许多小“步进”,每做完一“步进” 就让 JavaScript 应用逻辑执行一小会儿,垃圾回收与应用逻辑交替执行直到标记阶段完成