
##. Number和parseInt的区别
   1. Number用于将所有类型的数据转化为数字， parseInt主要用于将字符串转化为数字
   2. Number会将布尔类型，undefinded null 空字符串等转化为数字0或1 而parseInt则会将他们都转化为NaN
   3. 当Number传参为字符串时，去掉两边引号后都是数字时才会将他们转化为数字，否则就是NaA
   4. 当parseInt传入的字符串前面有数字时，会将前面数字部分转化为数字


##. xss攻击原理及防范
1. xss-跨站脚本攻击 向目标网站植入恶意的脚本，用户打开这些网站后会恶意的代码会自动执行或者通过一些点击交互事件触发
2. xss攻击分为反射型、存储型、和dom型三种
3. 反射型- 恶意代码被当做正常的数据提交给后台，后台处理后返回给前端
4. 存储型 恶意代码被提交到数据库中，用户打开网页后从数据库取出返回给浏览器执行
5. dom型，利用script，img,iframe， a 等标签的植入恶意的代码
### 危害-可以窃取网站用户的重要数据，操控当前页面的样式，重定向到其它网站。。。
### xss防范
1. 设置HttpOnly以避免cookie劫持的危险。
2. 对诸如<script>、<img>、<a>等标签进行过滤
3. 编码，像一些常见的符号，如<>在输入的时候要对其进行转换编码，这样做浏览器是不会对该标签进行解释执行的，同时也不影响显示效果


## csrf攻击原理及防范
1. 跨站请求伪造 用户登录了网站A，网站B诱导用户进入网站B，网站B偷偷自动提交了向网站B的请求（比如构造了一个表单），请求携带A网站的cookie到了网站A的后台服务器。

###  csrfs防范
1. 对于所有请求采用token验证或其他请求头验证手段
2. 充分利用好cookie的SameSite属性
3. origin属性和referer属性




## 首屏优化

### 首屏和白屏时间的基本概念
1. 首屏时间--浏览器从响应网址输入到首屏内容渲染完成的时间，这个时候页面不一定完全渲染完成，只是当前视图渲染完成
2. 白屏时间--浏览器从响应网址输入到开始显示内容的时间
3. 白屏时间：performance.timing.responseStart - performance.timing.navigationStart
4. 首屏时间： performance.getEntriesByName("first-contentful-paint")[0].startTime

### 怎么优化首屏时间
1. 采用cdn分发，多台服务器部署相同的副本，让离用户近或者压力小的的服务节点响应用户的请求
2. 资源压缩，gzip压缩可以将js和css等资源压缩到原来的一半以上
3. 利用缓存，设置合理的缓存字段，刷新或下次打开就可以快速从缓存中获取
4. 静态资源动态加载，比如现在的spa应用，非首页的页面可以按需加载，非当前的视图组件可以动态加载，非当前的视图的图片可以懒加载
5. 有长列表的可以延迟加载
6. ssr-服务端渲染，让服务器返回的吧首页的内容直接返回
7. 利用script标签的defer和async属性，功能独立且不要求马上执行的js文件，可以加入async属性，如果是优先级低的js，可以加入defer属性
8. 前端利用localStorage或者内存做一些缓存处理
9. 骨架屏-一般用于移动端，首屏加载完成前，通过的简单的元素占位，缓解等待焦虑
10. 利用http2.0，http2比http1.1有更好的传输性能，在接口小数量多的情况小尤其明显




##. http 2.0的优势在哪里

### http1.0/1.1的特点
1. http 1.0在发送请求结束后会断开tcp连接，下一个请求又要重新重建tcp连接
2. http 1.1连接默认是长连接，connection:keep-alive
3. http 1.1中一个TCP连接虽然支持多个请求，但是同一时刻只能处理一个请求，两个请求的生命周期不同重叠

### http 2 的的新特性
#### 支持多路复用
 1. 多个http请求可以在同一个TCP连接并行的进行
 2. HTTP2虽然只有一条TCP连接，但是在逻辑上分成了很多stream

 3. HTTP2把要传输的信息分割成一个个二进制帧，首部信息会被封装到HEADER Frame，相应的request body就放到DATA Frame,一个帧你可以看成路上的一辆车,只要给这些车编号，让1号车都走1号门出，2号车都走2号门出，就把不同的http请求或者响应区分开来了。但是，这里要求同一个请求或者响应的帧必须是有有序的，要保证FIFO的，但是不同的请求或者响应帧可以互相穿插。这就是HTTP2的多路复用，是不是充分利用了网络带宽，是不是提高了并发度？

####  单一长连接 
1. 统一域名下单个，在HTTP/2中，客户端向某个域名的服务器请求页面的过程中，只会创建一条TCP连接，即使这页面可能包含上百个资源
2. 原因 单一的连接能减少TCP握手带来的时延,另外TCP协议有个滑动窗口，有慢启动这回事，就是说每次建立新连接后，数据先是慢慢地传，然后滑动窗口慢慢变大
3. HTTP2中用一条单一的长连接，避免了创建多个TCP连接带来的网络开销，提高了吞吐量。

#### 头部压缩
随着 Web 功能越来越复杂，每个页面产生的请求数也越来越多，根据 HTTP Archive 的统计，当前平均每个页面都会产生上百个请求。越来越多的请求导致消耗在头部的流量越来越多，尤其是每次都要传输 UserAgent、Cookie 这类不会频繁变动的内容，完全是一种浪费。

#### 二进制格式
- 与Http1.x（文本协议）不同，Http2是一个二进制协议，所有的消息被http2拆分封装成更小的消息单元帧，并进行二进制编码。其中http1.x的首部信息被封装成HEADER帧和CONTINUATION帧，请求体被封装到DATA帧
- 二进制优势
1. 性能。二进制协议的解析效率超高，几乎没有解析代价；
2. 带宽。二进制协议没有冗余字段，占用带宽少；

#### 服务端推送Server Push
这个功能通常被称作“缓存推送”。主要的思想是：当一个客户端请求资源X，而服务器知道它很可能也需要资源Z的情况下，服务器可以在客户端发送请求前，主动将资源Z推送给客户端。



## 怎么优化图片
1. 图片压缩 可以选择通过网络在线压缩或者专门的npm包
2. 图片按需加载，真实图片加载完之前使用缩略图占位显示
3. 在不同的retina屏，可以让img标签加载不同的图片 <img>标签引入了srcset属性。
<picture>标签，<source>标签


9. 数组的join方法的参数不传会是怎么样
不传参数组转化为字符串会以逗号间隔 [1, 2, 3, 4] => '1,2,3,4'



## tcp和udp的区别
- tcp是面向连接的，需要经过握手，传输更加可靠。udp不是面向连接的，不需要握手即可发送，不保证可靠交付
- tcp传输速度更慢，占用的系统资源更多。udp传输速度更快，占用的系统资源也更少。
- tcp面向字节流，udp是面向报文，tcp是点对点，udp可以一对多
- tcp适用于对通信质量要求高的场景，udp适用于对速度和即时性要求高的场景，比如视频、语音通话等场景

1. TCP的优点： 可靠，稳定 TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。 TCP的缺点： 慢，效率低，占用系统资源高，易被攻击 TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。 而且，因为TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。
2. UDP的优点： 快，比TCP稍安全 UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击…… UDP的缺点： 不可靠，不稳定 因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。 基于上面的优缺点，那么： 什么时候应该使用TCP： 当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 在日常生活中，常见使用TCP协议的应用如下： 浏览器，用的HTTP FlashFXP，用的FTP Outlook，用的POP、SMTP Putty，用的Telnet、SSH QQ文件传输 ………… 什么时候应该使用UDP： 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 比如，日常生活中，常见使用UDP协议的应用如下： QQ语音 QQ视频 TFTP ……


## js延迟加载的方式
注意defer和async在不同浏览器的表现并不是完全一致的
1. defer和async都可以用于实现js的异步加载，避免或缓解对页面解析和渲染的阻塞
2. defer：defer属性只对外部脚本有用，defer属性的script可以放在页面任何位置，异步加载完后不会立即执行，但是会在DOMContentLoaded事件触发之前执行,这一点在Chrome和firefox的测试结果是一致的，可以理解为html的解析后执行（网上流行的版本是DOMContentLoaded事件之后执行，还有说在load事件之后触发，太误导人了）

3. async的异步加载完成后，加载脚本不会阻塞html解析渲染，加载完成开始解析执行脚本，此时会阻塞html的解析渲染 async在Chrome和firefox的测试结果不一致，同一个页面，Chrome中async在DOMContentLoaded后触发，firefox中则是在DOMContentLoaded之前触发

参考文章 [defer和async的区别](https://segmentfault.com/q/1010000000640869)


5. 输入url后的过程


8. https比http安全在哪里


9. CDN原理以及CDN获取最近节点资源的算法是什么(另加)