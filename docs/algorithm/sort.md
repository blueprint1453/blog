# 排序算法

## 冒泡排序
<p>冒泡排序算法的思路：</p>

1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2. 第一轮，对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一轮结束，最后的元素应该会是最大的数。
3. 第二轮，针对所有的元素重复以上的步骤，除了最后一个。
4. 第三轮，针对所有的元素重复以上的步骤，除了最后两个个。
5. 按照上述规律重复上面的步骤，直到没有任何一对数字需要比较。 

<p>根据上面的思路，冒泡排序有两层循环，第一层循环为所需要的轮数，第二层为每轮的比较次数</p>

```js
function sort(arr) {
  let len = arr.length
  for (let i = 0; i < len - 1; i++) { /*外循环为排序轮数*/ 
    for (let j = 0; j < len - i - 1; j++) { /*内循环为每次循环的次数*/
      if (arr[j] > arr[j+1]) {
        [arr[j], arr[j+1]] = [arr[j+1], arr[j]]
      }
    }
  }
  return arr
}
```

## 选择排序
<p>选择排序算法的思路：</p>

1. 第一轮 数组中的第一项元素跟他后面元素依次比较，若后面的元素比第一项大就交换他们俩个，这一轮结束后第一个元素就是最小的元素
2. 第二轮 数组中的第二项元素跟他后面元素依次比较，若后面的元素比第二项大就交换他们俩个，这一轮结束后第二项元素就是除第一项外最小的
4. 第三轮及以后，按照上述规律重复以上的步骤。

<p>简单来说，选择排序就是按顺序分别选出剩余元素中最小的元素，选择排序有两层循环，第一层循环为所需要的轮数，第二层为每轮的比较次数</p>

```js
function selectSort(arr) {
  for (let i = 0; i < arr.length - 1; i++) {  /*外循环为排序轮数 i表示当前这一轮最小的元素的位置*/ 
    for (let j = i + 1; j < arr.length; j++) { /*内循环为每次循环的次数*/
      if (arr[i] > arr[j]) {
        [arr[i], arr[j]] = [arr[j], arr[i]]
      }
    }
  }
  return arr
}
```

## 插入排序

<p>基本思想是将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增1的有序表</p>
<p>插入排序算法的思路：</p>

1. 第一轮 取数组第二个元素位置作为起点，按照逆序的顺序比较相邻的两个元素，索引大元素值比相邻的小就交换他们的位置
2. 第二轮 取数组第三个元素位置作为起点，按照逆序的顺序比较相邻的两个元素，索引大元素值比相邻的小就交换他们的位置
4. 第三轮及以后，按照上述规律重复以上的步骤。

```js
function insertSort(arr) {
  for (let i = 1; i < arr.length ; i++) { /*外循环为排序轮数 i表示当前这一轮进行比较起始位置*/ 
    for (let j = i; j >= 0; j--) { /*内循环为每次循环的次数 按照逆序方式比较相邻元素*/
      if (arr[j] < arr[j - 1]) {
        [arr[j], arr[j - 1]] = [arr[j - 1], arr[j]]
      } else {
        break
      }
    }
  }
  return arr
}
```

