(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{406:function(t,e,a){"use strict";a.r(e);var r=a(18),_=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"react组件的生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react组件的生命周期"}},[t._v("#")]),t._v(" react组件的生命周期")]),t._v(" "),a("p",[t._v("react组件的生命周期分为初始化渲染、更新、卸载三个大阶段，具体的执行过程如下")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("调用构造函数，初始化state")])]),t._v(" "),a("li",[a("p",[t._v("调用componentWillMount, 准备进入渲染阶段")])]),t._v(" "),a("li",[a("p",[t._v("执行render方法，将jsx转化为虚拟DOM")])]),t._v(" "),a("li",[a("p",[t._v("将虚拟DOM映射生成真实DOM，并触发componentDidMount方法")])]),t._v(" "),a("li",[a("p",[t._v("某一时刻，调用setState方法，进入更新渲染流程阶段")])]),t._v(" "),a("li",[a("p",[t._v("调用shouldComponentUpdate，可以在这里指示组件要不要进行更新渲染的操作")])]),t._v(" "),a("li",[a("p",[t._v("调用componentWillUpdate方法")])]),t._v(" "),a("li",[a("p",[t._v("执行render方法，生成新的虚拟DOM")])]),t._v(" "),a("li",[a("p",[t._v("新旧虚拟DOM比对，更新变化的节点 触发componentDidupdate方法")])])]),t._v(" "),a("p",[t._v("注意5-6讲的是state变化的更新，如果是props变化导致的更新，那么会增加componentWillRecieveProps这个个生命周期方法")]),t._v(" "),a("ol",{attrs:{start:"9"}},[a("li",[t._v("组件卸载,触发componentWillUnmount方法")])]),t._v(" "),a("h2",{attrs:{id:"react-16-之后生命周期的变化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-16-之后生命周期的变化"}},[t._v("#")]),t._v(" react 16 之后生命周期的变化")]),t._v(" "),a("ul",[a("li",[t._v("挂载阶段")])]),t._v(" "),a("ol",[a("li",[t._v("constructor")]),t._v(" "),a("li",[t._v("static getDerivedStateFromProps (UNSAFE_componentWillMount 不推荐使用)")]),t._v(" "),a("li",[t._v("render")]),t._v(" "),a("li",[t._v("componentDidMount")])]),t._v(" "),a("ul",[a("li",[t._v("更新阶段")])]),t._v(" "),a("ol",[a("li",[t._v("static getDrivedStateFromProps (UNSAFE_componentWillReceiveProps不推荐使用)")]),t._v(" "),a("li",[t._v("shouldComponentUpdate")]),t._v(" "),a("li",[t._v("render")]),t._v(" "),a("li",[t._v("getSnapshotBeforeUpdate  (UNSAFE_componentWillUpdate不推荐使用)")]),t._v(" "),a("li",[t._v("componentDidUpdate")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("卸载\ncomponentWillUnmount")])]),t._v(" "),a("li",[a("p",[t._v("补充 错误处理")])])]),t._v(" "),a("ol",[a("li",[t._v("static getDrivedStateFromError")]),t._v(" "),a("li",[t._v("componentDidCatch")])]),t._v(" "),a("h2",{attrs:{id:""}},[a("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")]),t._v(" -----------------------------------------------------------------------")]),t._v(" "),a("h2",{attrs:{id:"setstate方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setstate方法"}},[t._v("#")]),t._v(" setState方法")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("setState并不能保证会立即更新，通常情况下会延迟调用。setState会将更新缓冲到一个队列中，将当前的react事件处理程序结束后批量进行更新渲染。")])]),t._v(" "),a("li",[a("p",[t._v("之所以要延迟更新，是因为当前的执行环境可能会同时有多次的setState的调用，如果调用setState后立即更新，连续的多次的更新会影响性能。")])]),t._v(" "),a("li",[a("p",[t._v("什么情况下同步，什么情况延迟更新呢？\n当setState在react的事件处理程序中被调用时，如dom合成事件，生命周期方法中，setState的更新时延迟的\n当setState在定时器，网络请求，或promise回调中，setState的更新时同步的，可以立即获取新的state")])]),t._v(" "),a("li",[a("p",[t._v("setState延迟更新的原理\n在setState的内部实现中，会根据一个叫做isBatchingUpdates标识判断是将更新放入队列中还是直接更新，默认情况下isBatchingUpdate是false，但是有一个batchedUpdates方法，他会将isBatchingUpdate设置为true，而react的事件处理程序每次被调用时，都会调用batchedUpdates方法")])])]),t._v(" "),a("h2",{attrs:{id:"调用-setstate-之后发生了什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#调用-setstate-之后发生了什么"}},[t._v("#")]),t._v(" 调用 setState 之后发生了什么？")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/43522965",target:"_blank",rel:"noopener noreferrer"}},[t._v("揭密React setState"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#-2"}},[t._v("#")]),t._v(" -----------------------------------------------------------------------")]),t._v(" "),a("h2",{attrs:{id:"react的diff算法原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react的diff算法原理"}},[t._v("#")]),t._v(" react的diff算法原理")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("参考文章 "),a("a",{attrs:{href:"https://www.cnblogs.com/forcheng/p/13246874.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("深入理解React：diff 算法"),a("OutboundLink")],1)])]),t._v(" "),a("li",[a("p",[t._v("react diff策略一 Web UI中DOM节点跨层级的移动操作特别少，可以忽略不计，所以react只对虚拟dom树的同一层级进行比对。如果是跨层级的话，只有创建节点和删除节点的操作。")])]),t._v(" "),a("li",[a("p",[t._v("相同类型的组件具有类似的dom结构 对于不同类型的组件，默认不需要进行比较操作，直接重新创建。\n对于同类型组件， 通过让开发人员自定义shouldComponentUpdate()方法来进行比较优化，减少组件不必要的比较")])]),t._v(" "),a("li",[a("p",[t._v("对于同一层级的一组子节点，通过唯一id区分\n当节点处于同一层级时，diff提供三种节点操作：删除、插入、移动。")])])]),t._v(" "),a("ol",[a("li",[t._v("新的虚拟DOM出现新的节点时，执行插入操作")]),t._v(" "),a("li",[t._v("新的虚拟dom中，某个节点已经改变，执行删除操作")]),t._v(" "),a("li",[t._v("新的dom中，兄弟节点本身没有发生变化，只是兄弟间顺序发生变化，执行移动操作")])]),t._v(" "),a("h2",{attrs:{id:"-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#-3"}},[t._v("#")]),t._v(" -----------------------------------------------------------------------")]),t._v(" "),a("h2",{attrs:{id:"高阶组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#高阶组件"}},[t._v("#")]),t._v(" 高阶组件")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/61711492?utm_source=wechat_session",target:"_blank",rel:"noopener noreferrer"}},[t._v("React 中的高阶组件及其应用场景"),a("OutboundLink")],1),t._v("\n定义 接受组件作为参数，返回新的组件的函数")]),t._v(" "),a("ul",[a("li",[t._v("高阶组件是一个纯函数，不应该对输入组件做更改")]),t._v(" "),a("li",[t._v("高阶组件应该避免在render方法中使用，因为这样做会导致每次render都重新执行一遍组件的创建操作")]),t._v(" "),a("li",[t._v("不能在函数式（无状态）组件上使用 ref 属性，因为它没有实例")])]),t._v(" "),a("p",[t._v("##高级组件主要有两种形式，属性代理和反向继承##")]),t._v(" "),a("ol",[a("li",[t._v("属性代理 返回一个继承了react，Component的新组件的高阶组件")])]),t._v(" "),a("ul",[a("li",[t._v("操作 props 比如新增props")]),t._v(" "),a("li",[t._v("抽离state 将子件共同的状态的方法抽取到state，然后在高阶组件中合并到props中")]),t._v(" "),a("li",[t._v("通过 ref 访问到组件实例")]),t._v(" "),a("li",[t._v("用其他元素包裹传入的组件 WrappedComponent")])]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("反向继承 返回了一个继承了传入的组件的新组建")])]),t._v(" "),a("ul",[a("li",[t._v("操作 state 可以操作传入组件的state，一般不建议做")]),t._v(" "),a("li",[t._v("渲染劫持 对传入组件的渲染进行改写")])]),t._v(" "),a("p",[t._v("##高阶组件的问题##")]),t._v(" "),a("ol",[a("li",[t._v("静态方法丢失")]),t._v(" "),a("li",[t._v("ref属性无法透传")]),t._v(" "),a("li")]),t._v(" "),a("h2",{attrs:{id:"-4"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#-4"}},[t._v("#")]),t._v(" -----------------------------------------------------------------------")]),t._v(" "),a("h2",{attrs:{id:"合成事件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#合成事件"}},[t._v("#")]),t._v(" 合成事件")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("react的事件处理采用合成事件，合成事件是对浏览器原生事件的跨浏览器封装，拥有和浏览器原生事件相同的接口。")])]),t._v(" "),a("li",[a("p",[t._v("react合成事件采用对象池进行管理，事件处理程序在调用结束后会被回收，其属性会被重置为null，所以异步访问的合成事件某个属性的话会出现无效的情况")])]),t._v(" "),a("li",[a("p",[t._v("解决合成事件属性异步访问无效的情况？")]),t._v(" "),a("ol",[a("li",[t._v("可以使用变量保存方式")]),t._v(" "),a("li",[t._v("调用e.pesist(),该方法会将合成事件从对象池移除，就不会被回收重置了。但是react 17已经废除了该方法")])])])]),t._v(" "),a("h2",{attrs:{id:"react-hooks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-hooks"}},[t._v("#")]),t._v(" react hooks")]),t._v(" "),a("p",[t._v("为复用react组件代码提供的一种方案，在之前主要通过高阶组件和render props来实现,hooks让函数式组建拥有了自己的状态")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("react内置了useState,useEffect,useContext等hooks")])]),t._v(" "),a("li",[a("p",[t._v("useState接受一个初始值，返回一个state和更新state的函数")])]),t._v(" "),a("li",[a("p",[t._v("useEffect接受一个函数作为参数，会在每次组件渲染后触发")]),t._v(" "),a("ol",[a("li",[t._v("useEffect会在每次渲染前把之前订阅清理掉")]),t._v(" "),a("li",[t._v("useEffect在渲染后延迟更新，不会阻塞ui")]),t._v(" "),a("li",[t._v("useEffect每次渲染都会触发，为了避免每次触发，可以在第二个参数数组中放入其依赖的变量")])])]),t._v(" "),a("li",[a("p",[t._v("useContext接受一个react context对象并返回context的当前值，其值是有上层组件中距离当前组件最近的context的Provider决定")])]),t._v(" "),a("li",[a("p",[t._v("useReducer useState 的替代方案。它接收一个形如 (state, action) => newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法")])]),t._v(" "),a("li",[a("p",[t._v("hooks使用规则")])])]),t._v(" "),a("ol",[a("li",[t._v("只在react函数的顶层使用hooks，不要在循环中、条件语句中和内部函数中使用hooks")]),t._v(" "),a("li",[t._v("只在react函数中调用hooks，不要在普通js函数中使用他们")]),t._v(" "),a("li")]),t._v(" "),a("h2",{attrs:{id:"分割线"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分割线"}},[t._v("#")]),t._v(" -----------------------------分割线------------------------------------------")]),t._v(" "),a("h2",{attrs:{id:"react的性能优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react的性能优化"}},[t._v("#")]),t._v(" react的性能优化")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/74229420?utm_source=wechat_session",target:"_blank",rel:"noopener noreferrer"}},[t._v("浅谈React性能优化的方向"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"分割线-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分割线-2"}},[t._v("#")]),t._v(" -----------------------------分割线------------------------------------------")]),t._v(" "),a("h2",{attrs:{id:"说说对redux"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说说对redux"}},[t._v("#")]),t._v(" 说说对redux")]),t._v(" "),a("h2",{attrs:{id:"分割线-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分割线-3"}},[t._v("#")]),t._v(" -----------------------------分割线------------------------------------------")]),t._v(" "),a("h2",{attrs:{id:"说说对react-redux、connect的实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说说对react-redux、connect的实现原理"}},[t._v("#")]),t._v(" 说说对react-redux、connect的实现原理")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("react-redux将组件分为容器组件和ui组件\nui组件就是只显示视图的组件，不会涉及到redux api的操作\n容器组件就是包含状态逻辑的组件，会使用redux的api")])]),t._v(" "),a("li",[a("p",[t._v("react-redux提供了一个Provider组件，其内部通过react context将store往组件树中向下传递")])]),t._v(" "),a("li",[a("p",[t._v("react-redux 提供了一个connect函数，这是一个高阶函数，其返回值是一个高阶组件，connect")])]),t._v(" "),a("li",[a("p",[t._v("可以接受两个参数，分别负责被包裹组件的组件的输入和输出")])])]),t._v(" "),a("ol",[a("li",[t._v("mapStateToProps 第一个参数是一个函数，返回了一个对象，将state映射成props")]),t._v(" "),a("li",[t._v("mapDispatchToProps 第二个参数是一个函数，返回一个对象，将用户的输入映射成redux的action")]),t._v(" "),a("li",[t._v("connect函数返回的高阶组件内部代码中，订阅了redux store的变化，并且在变化后刷新组件，在render函数返回的组件中注入了mapStateToProp和mapDispatchToProps，这样组件就可以通过props使用他们了")])]),t._v(" "),a("h2",{attrs:{id:"分割线-4"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分割线-4"}},[t._v("#")]),t._v(" -----------------------------分割线------------------------------------------")]),t._v(" "),a("h2",{attrs:{id:"react-context"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-context"}},[t._v("#")]),t._v(" react context")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("context有关的文章\n"),a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/50336226",target:"_blank",rel:"noopener noreferrer"}},[t._v("避免React Context导致的重复渲染"),a("OutboundLink")],1),t._v(" "),a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/74229420?utm_source=wechat_session",target:"_blank",rel:"noopener noreferrer"}},[t._v("浅谈React性能优化的方向"),a("OutboundLink")],1)])]),t._v(" "),a("li",[a("p",[t._v("context api\ncontext api 为react应用提供了不需要层层传递props就能在组件数传递数据的方案")])]),t._v(" "),a("li",[a("p",[t._v("合理使用context api\ncontext可以穿透React.memo和shouldupdate的比对，一旦context的值发生，会引起context包裹的所有的子组件的重新渲染。所以context api的使用需要遵循一些原则")])])]),t._v(" "),a("ol",[a("li",[t._v("context中只放置必要的、关键的、被大多数组件共享的数据，比如鉴权组价")]),t._v(" "),a("li",[t._v("粗粒度的订阅context，在父组件订阅context，通过props传递给子组件")]),t._v(" "),a("li",[t._v("将context的provider组件封装成独立的组件在使用可以避免不必要的渲染。")])]),t._v(" "),a("h2",{attrs:{id:"分割线-5"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分割线-5"}},[t._v("#")]),t._v(" -----------------------------分割线------------------------------------------")]),t._v(" "),a("h2",{attrs:{id:"react-中的元素和组件有什么不同"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-中的元素和组件有什么不同"}},[t._v("#")]),t._v(" React 中的元素和组件有什么不同")]),t._v(" "),a("ul",[a("li",[t._v("元素是不可变的普通对象，用来描述你想要渲染的组件或 DOM 节点。  元素一旦被创建，你就无法更改它的子元素或者属性。一个元素就像电影的单帧：它代表了某个特定时刻的 UI。")]),t._v(" "),a("li",[t._v("组件可以是类或者函数，他将 props 作为输入然后返回一个元素的树形结构作为输出。")])])])}),[],!1,null,null,null);e.default=_.exports}}]);