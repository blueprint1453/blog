(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{380:function(t,s,a){"use strict";a.r(s);var v=a(19),l=Object(v.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"性能优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#性能优化"}},[t._v("#")]),t._v(" 性能优化")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("CSS放到head里面、js放到body前面，以及js的异步加载（async、defer）等优化。")])]),t._v(" "),a("li",[a("p",[t._v("减少静态资源的体积")])])]),t._v(" "),a("p",[t._v("压缩静态资源：合并打包的js、css文件体积一般会比较大，一些图片也会比较大，这个时候必须要压缩处理\n编写高效率的CSS, 使用less、sass等预处理器时一般建议嵌套3层即可，不要嵌套过深\n服务端开启gzip压缩：大招，最近刚知晓，真是太牛逼了，一般的css、js文件能压缩60、70%\n避免代码冗余和没有用到的代码被打包")]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("使用缓存")])]),t._v(" "),a("p",[t._v("200 OK (from cache) 是浏览器没有跟服务器确认，直接用了浏览器缓存；\n而 304 Not Modified 是浏览器和服务器多确认了一次缓存的有效性，然后再使用的缓存。")]),t._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[t._v("代码层面的优化")])]),t._v(" "),a("p",[t._v("对对于 Scroll 和 Touchmove 这类事件操作采用防抖，节流\n定会器和注册事件在不需要时手动清理掉")]),t._v(" "),a("ol",{attrs:{start:"5"}},[a("li",[a("p",[t._v("路由、图片懒加载")])]),t._v(" "),a("li",[a("p",[t._v("JavaScript 很快，DOM 很慢,避免频繁的DOM操作,使用 requestAnimationFrame 来更新页面")])]),t._v(" "),a("li",[a("p",[t._v("每一帧实际上都包含下列步骤：")]),t._v(" "),a("ul",[a("li",[t._v("JavaScript：改变元素样式，添加元素到 DOM 中等等")]),t._v(" "),a("li",[t._v("Style：元素的类或者style改变了，这个时候需要重新计算元素的样式")]),t._v(" "),a("li",[t._v("Layout：需要重新计算元素的具体尺寸")]),t._v(" "),a("li",[t._v("Paint：将元素的绘制的图层上")]),t._v(" "),a("li",[t._v("Composite：合并多个图层")])])])]),t._v(" "),a("p",[t._v("当然也不是说每一帧都会进行这些操作。当你的 JavaScript 改变了某个 layout 属性，\n比如元素的 width 和height 或者 top 等等，浏览器就会重新计算布局，并对整个页面进行重排。\n如果修改了 background、color 这样的仅仅会让页面重绘的属性，这不会影响页面的布局，\n浏览器会跳过计算布局（layout）的过程，只进行重绘（paint）。")]),t._v(" "),a("ol",{attrs:{start:"8"}},[a("li",[t._v("使用 Web Worker 来处理复杂的计算")])])])}),[],!1,null,null,null);s.default=l.exports}}]);