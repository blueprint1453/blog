(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{365:function(t,i,a){"use strict";a.r(i);var e=a(19),r=Object(e.a)({},(function(){var t=this,i=t.$createElement,a=t._self._c||i;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"css基础理论"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#css基础理论"}},[t._v("#")]),t._v(" css基础理论")]),t._v(" "),a("h2",{attrs:{id:"css盒模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#css盒模型"}},[t._v("#")]),t._v(" css盒模型")]),t._v(" "),a("p",[t._v("简介：就是用来装页面上的元素的矩形区域。CSS中的盒子模型包括IE盒子模型和标准的W3C盒子模型。")]),t._v(" "),a("p",[t._v("border-sizing(有3个值哦)：border-box,padding-box,content-box.")]),t._v(" "),a("p",[t._v("区别：从图中我们可以看出，这两种盒子模型最主要的区别就是width的包含范围，在标准的盒子模型中，width指content部分的宽度，在IE盒子模型中，width表示content+padding+border这三个部分的宽度，故这使得在计算整个盒子的宽度时存在着")]),t._v(" "),a("p",[t._v("差异：")]),t._v(" "),a("ul",[a("li",[t._v("标准盒子模型的盒子宽度：左右border+左右padding+width")]),t._v(" "),a("li",[t._v("IE盒子模型的盒子宽度：width")]),t._v(" "),a("li",[t._v("在CSS3中引入了box-sizing属性，box-sizing:content-box;表示标准的盒子模型，box-sizing:border-box表示的是IE盒子模型")]),t._v(" "),a("li",[t._v("最后，前面我们还提到了，box-sizing:padding-box,这个属性值的宽度包含了左右padding+width\n也很好理解性记忆，包含什么，width就从什么开始算起。")])]),t._v(" "),a("h2",{attrs:{id:"画一条0-5px的线"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#画一条0-5px的线"}},[t._v("#")]),t._v(" 画一条0.5px的线")]),t._v(" "),a("p",[t._v("采用meta viewport的方式\n采用 border-image的方式\n采用transform: scale()的方式\n采用线性渐变")]),t._v(" "),a("h2",{attrs:{id:"link标签和import标签的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#link标签和import标签的区别"}},[t._v("#")]),t._v(" link标签和import标签的区别")]),t._v(" "),a("p",[t._v("link属于html标签，而@import是css提供的\n页面被加载时，link会同时被加载，而@import引用的css会等到页面加载结束后加载。\nlink是html标签，因此没有兼容性，而@import只有IE5以上才能识别。\nlink方式样式的权重高于@import的。")]),t._v(" "),a("h2",{attrs:{id:"flex布局"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flex布局"}},[t._v("#")]),t._v(" Flex布局")]),t._v(" "),a("p",[t._v('Flex是Flexible Box的缩写，意为"弹性布局"，用来为盒状模型提供最大的灵活性。\n布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。\n简单的分为容器属性和元素属性\n容器的属性：')]),t._v(" "),a("p",[t._v("flex-direction：决定主轴的方向（即子item的排列方法）\n.box {\nflex-direction: row | row-reverse | column | column-reverse;\n}\nflex-wrap：决定换行规则\n.box{\nflex-wrap: nowrap | wrap | wrap-reverse;\n}\nflex-flow：\n.box {\nflex-flow:  || ;\n}\njustify-content：对其方式，水平主轴对齐方式\nalign-items：对齐方式，竖直轴线方向")]),t._v(" "),a("p",[t._v("项目的属性（元素的属性）：")]),t._v(" "),a("p",[t._v("order属性：定义项目的排列顺序，顺序越小，排列越靠前，默认为0\nflex-grow属性：定义项目的放大比例，即使存在空间，也不会放大\nflex-shrink属性：定义了项目的缩小比例，当空间不足的情况下会等比例的缩小，如果定义个item的flow-shrink为0，则为不缩小\nflex-basis属性：定义了在分配多余的空间，项目占据的空间。\nflex：是flex-grow和flex-shrink、flex-basis的简写，默认值为0 1 auto。\nalign-self：允许单个项目与其他项目不一样的对齐方式，可以覆盖align-items，默认属性为auto，表示继承父元素的align-items")]),t._v(" "),a("p",[t._v("参考阮一峰文章链接：\n"),a("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool",target:"_blank",rel:"noopener noreferrer"}},[t._v("语法篇"),a("OutboundLink")],1),t._v(" "),a("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2015/07/flex-examples.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("实例篇"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"bfc（块级格式化上下文，用于清楚浮动，防止margin重叠等）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bfc（块级格式化上下文，用于清楚浮动，防止margin重叠等）"}},[t._v("#")]),t._v(" BFC（块级格式化上下文，用于清楚浮动，防止margin重叠等）")]),t._v(" "),a("p",[t._v("直译成：块级格式化上下文，是一个独立的渲染区域，并且有一定的布局规则。")]),t._v(" "),a("ul",[a("li",[t._v("BFC区域不会与float box重叠")]),t._v(" "),a("li",[t._v("BFC是页面上的一个独立容器，子元素不会影响到外面")]),t._v(" "),a("li",[t._v("计算BFC的高度时，浮动元素也会参与计算")])]),t._v(" "),a("p",[t._v("哪些情况会产生BFC:")]),t._v(" "),a("ul",[a("li",[t._v("根元素")]),t._v(" "),a("li",[t._v("float不为none的元素")]),t._v(" "),a("li",[t._v("position为fixed和absolute的元素")]),t._v(" "),a("li",[t._v("display为inline-block、table-cell、table-caption，flex，inline-flex的元素")]),t._v(" "),a("li",[t._v("overflow不为visible的元素")])]),t._v(" "),a("h2",{attrs:{id:"水平垂直居中"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#水平垂直居中"}},[t._v("#")]),t._v(" 水平垂直居中")]),t._v(" "),a("h2",{attrs:{id:"实现水平居中"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现水平居中"}},[t._v("#")]),t._v(" 实现水平居中")]),t._v(" "),a("p",[t._v("text-align:center、 margin：auto、 flex布局设置justify-content：center、 绝对定位+tansfrom/margin-left属性、tabel布局")]),t._v(" "),a("h2",{attrs:{id:"实现垂直居中"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现垂直居中"}},[t._v("#")]),t._v(" 实现垂直居中")]),t._v(" "),a("p",[t._v("vertical:middle、line-height跟高度等高、 flex布局设置align-item:center、 绝对定位+tansfrom/margin-left属性")]),t._v(" "),a("h2",{attrs:{id:"双边距重叠问题（外边距折叠）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#双边距重叠问题（外边距折叠）"}},[t._v("#")]),t._v(" 双边距重叠问题（外边距折叠）")]),t._v(" "),a("p",[t._v("多个相邻（兄弟或者父子关系）普通流的块元素垂直方向marigin会重叠\n折叠的结果为：\n两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。\n两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。\n两个外边距一正一负时，折叠结果是两者的相加的和。")]),t._v(" "),a("h2",{attrs:{id:"visibility-hidden-opacity-0，display-none"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#visibility-hidden-opacity-0，display-none"}},[t._v("#")]),t._v(" visibility=hidden, opacity=0，display:none")]),t._v(" "),a("p",[t._v("opacity=0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如click事件，那么点击该区域，也能触发点击事件的visibility=hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件display=none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉一样。")]),t._v(" "),a("h2",{attrs:{id:"js动画"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js动画"}},[t._v("#")]),t._v(" JS动画")]),t._v(" "),a("ol",[a("li",[t._v("缺点：")])]),t._v(" "),a("ul",[a("li",[t._v("JavaScript在浏览器的主线程中运行，而主线程中还有其它需要运行的JavaScript脚本、样式计算、布局、绘制任务等,对其干扰导致线程可能出现阻塞，从而造成丢帧的情况。")]),t._v(" "),a("li",[t._v("代码的复杂度高于CSS动画")])]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("优点：")])]),t._v(" "),a("ul",[a("li",[t._v("JavaScript动画控制能力很强, 可以在动画播放过程中对动画进行控制：开始、暂停、回放、终止、取消都是可以做到的。")]),t._v(" "),a("li",[t._v("动画效果比css3动画丰富,有些动画效果，比如曲线运动,冲击闪烁,视差滚动效果，只有JavaScript动画才能完成")]),t._v(" "),a("li",[t._v("CSS3有兼容性问题，而JS大多时候没有兼容性问题")])]),t._v(" "),a("h2",{attrs:{id:"css动画"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#css动画"}},[t._v("#")]),t._v(" CSS动画")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("缺点：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("运行过程控制较弱,无法附加事件绑定回调函数。CSS动画只能暂停,不能在动画中寻找一个特定的时间点，不能在半路反转动画，不能变换时间尺度，不能在特定的位置添加回调函数或是绑定回放事件,无进度报告")])]),t._v(" "),a("li",[a("p",[t._v("代码冗长。想用 CSS 实现稍微复杂一点动画,最后CSS代码都会变得非常笨重。")])])])]),t._v(" "),a("li",[a("p",[t._v("优点： 浏览器可以对动画进行优化。")])])]),t._v(" "),a("p",[t._v("浏览器使用与 requestAnimationFrame 类似的机制，requestAnimationFrame比起setTimeout，setInterval设置动画的优势主要是:1)requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成,并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率,一般来说,这个频率为每秒60帧。2)在隐藏或不可见的元素中requestAnimationFrame不会进行重绘或回流，这当然就意味着更少的的cpu，gpu和内存使用量。\n强制使用硬件加速 （通过 GPU 来提高动画性能）")]),t._v(" "),a("p",[t._v("如果动画只是简单的状态切换，不需要中间过程控制，在这种情况下，css动画是优选方案。它可以让你将动画逻辑放在样式文件里面，而不会让你的页面充斥 Javascript 库。然而如果你在设计很复杂的富客户端界面或者在开发一个有着复杂UI状态的 APP。那么你应该使用js动画，这样你的动画可以保持高效，并且你的工作流也更可控。所以，在实现一些小的交互动效的时候，就多考虑考虑CSS动画。对于一些复杂控制的动画，使用javascript比较可靠。 c")])])}),[],!1,null,null,null);i.default=r.exports}}]);