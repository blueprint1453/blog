(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{389:function(e,l,v){"use strict";v.r(l);var t=v(20),_=Object(t.a)({},(function(){var e=this,l=e.$createElement,v=e._self._c||l;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"js的执行机制-事件循环"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#js的执行机制-事件循环"}},[e._v("#")]),e._v(" js的执行机制-事件循环")]),e._v(" "),v("ol",[v("li",[v("p",[e._v("为什么会有事件循环?\njs引擎是单线程的，为了协调用户交互、渲染、网络事件以及后台脚本任务，必须使用事件循环")])]),e._v(" "),v("li",[v("p",[e._v("事件循环的流程")]),e._v(" "),v("ol",[v("li",[e._v("从任务队列取出一个宏任务，先执行其中的同步代码")]),e._v(" "),v("li",[e._v("执行完同步代码后，检查微任务队列，执行微任务，如果微任务当中有另外的微任务，新任务也将执行，\n微任务")])])]),e._v(" "),v("li",[v("p",[e._v("进入更新渲染阶段，浏览器并不一定会渲染，需要判断是否需要渲染\n下述情况不会执行渲染操作")]),e._v(" "),v("ol",[v("li",[e._v("没有任何Dom的操作，或者浏览器判断更新渲染并不会有视觉的改变，")]),e._v(" "),v("li",[e._v("帧动画回调为空，即requestAnimationFrame回调为空")])])]),e._v(" "),v("li",[v("p",[e._v("如果浏览器判断不需要渲染，那么下面的步骤5/6/7/8也不会发生")])]),e._v(" "),v("li",[v("p",[e._v("窗口的大小发生了变化resize事件触发，页面发生了滚动，执行 scroll 事件")])]),e._v(" "),v("li",[v("p",[e._v("执行帧动画回调，也就是 requestAnimationFrame 的回调")])]),e._v(" "),v("li",[v("p",[e._v("执行 IntersectionObserver、MutationObserver 的回调")])]),e._v(" "),v("li",[v("p",[e._v("重新渲染绘制用户界面")])]),e._v(" "),v("li",[v("p",[e._v("检查是否有宏任务和微任务，如果美哦与，则执行空闲周期的算法，执行 requestIdleCallback 的回调函数")])])]),e._v(" "),v("p",[e._v("几个重要结论：")]),e._v(" "),v("ol",[v("li",[e._v("并不是每个宏任务之间都会有渲染操作，同理每个事件循环之间也是这样")]),e._v(" "),v("li",[e._v("requestAnimationFrame的回调事件是在浏览器渲染之前发生")]),e._v(" "),v("li",[e._v("requestIdleCallback的回调事件是在浏览器渲染之后发生")]),e._v(" "),v("li",[e._v("resize和scroll事件其实自带节流，它只在 Event Loop 的渲染阶段去执行事件")])])])}),[],!1,null,null,null);l.default=_.exports}}]);